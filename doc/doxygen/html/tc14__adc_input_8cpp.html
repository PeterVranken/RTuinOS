<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RTuinOS: tc14_adcInput.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RTuinOS&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">Small Scale RTOS for Arduino 1.0.5</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('tc14__adc_input_8cpp.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>tc14_adcInput.cpp File Reference</h1>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;Arduino.h&gt;</code><br/>
<code>#include &quot;rtos.h&quot;</code><br/>
<code>#include &quot;rtos_assert.h&quot;</code><br/>
<code>#include &quot;gsl_systemLoad.h&quot;</code><br/>
<code>#include &quot;stdout.h&quot;</code><br/>
<code>#include &quot;aev_applEvents.h&quot;</code><br/>
<code>#include &quot;dpy_display.h&quot;</code><br/>
<code>#include &quot;but_button.h&quot;</code><br/>
<code>#include &quot;clk_clock.h&quot;</code><br/>
<code>#include &quot;adc_analogInput.h&quot;</code><br/>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14__adc_input_8cpp.html#aeb7a7ba1ab7e0406f1b5ab36d579f585">LED</a>&#160;&#160;&#160;13</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bf303a995133cba14f6db16df608457"></a><!-- doxytag: member="tc14_adcInput.cpp::TI_FLASH" ref="a9bf303a995133cba14f6db16df608457" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TI_FLASH</b>&#160;&#160;&#160;150</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07517f0a842fa80d005f2e78e535ae3f"></a><!-- doxytag: member="tc14_adcInput.cpp::NO_AVERAGED_SAMPLES" ref="a07517f0a842fa80d005f2e78e535ae3f" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NO_AVERAGED_SAMPLES</b>&#160;&#160;&#160;5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>SCALING_BIN_TO_V</b>(binVal)</td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>idxTaskOnADCComplete</b>, 
<br/>
&#160;&#160;<b>idxTaskRTC</b>, 
<br/>
&#160;&#160;<b>idxTaskIdleFollower</b>, 
<br/>
&#160;&#160;<b>idxTaskButton</b>, 
<br/>
&#160;&#160;<b>idxTaskDisplayVoltage</b>, 
<br/>
&#160;&#160;<b>noTasks</b>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14__adc_input_8cpp.html#ad146c8310465410fd5600083b174eb00">rtos_enableIRQUser00</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14__adc_input_8cpp.html#a4fc01d736fe50cf5b977f755b675f11d">setup</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14__adc_input_8cpp.html#afe461d27b9c48d5921c00d521181f12f">loop</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2aad6f0dd6cecb1da58f7af8bbbd7cd"></a><!-- doxytag: member="tc14_adcInput.cpp::_cpuLoad" ref="ac2aad6f0dd6cecb1da58f7af8bbbd7cd" args="" -->
volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_cpuLoad</b> = 200</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Test case 14 of RTuinOS. A user interrupt is applied to pick the results of an analog input channel, which is running in regular, hardware triggered Auto Trigger Mode.<br/>
 It could seem to be straight forward, to use the timing capabilities of an RTOS to trigger the conversions of an ADC; a regular task would be used to do so. However, signal processing of fluctuating input signals by means of regularly sampling the input suffers from incorrect timing. Although the timing of a regular task is very precise in mean, the actual points in time, when a task is invoked are not precisely equidistant. The invocations may be delayed by an arbitrary, fluctuating tiny time span. This holds true even for a task of high priority -- although the so called jitter will be little here. If the signal processing assumes regular sampling of the input but actually does do this with small time shifts, it will see an error, which is approximately equal to the first derivative of the input signal times the time shift. The latter is a random quantity so the error also is a random quantity proportional to the derivative of the input signal. In the frequency domain this mean that the expected error increases linearly with the input frequency. Consequently, task triggered ADC conversions must be used only for slowly changing input signals, it might e.g. be adequate for reading a temperature input. All other applications need to trigger the conversions by a software independent, accurate hardware signal. The software becomes a slave of this hardware trigger. The jitter of the task now only doing the data evaluation doesn't matter at all.<br/>
 This RTuinOS sample application uses timer/counter 0 in the unchanged Arduino standard configuration to trigger the conversions of the ADC. The overflow interrupt is used for this purpose yielding a conversion rate of about 977 Hz. A task of high priority is awaken on each conversion-complete event and reads the conversion result. The read values are down-sampled and passed to a much slower secondary task, which prints them on the Arduino LCD shield (using the LiquidCrystal library).<br/>
 Proper down-sampling is a CPU time consuming operation, which is hard to implement on a tiny eight Bit controller. Here we use the easiest possible to implement filter with rectangular impulse response. It adds the last recent N input values and divides the result by N. We exploit the fact, that we have 10 Bit ADC values but use a 16 Bit arithmetics anyway: We can safely sum up up to 64 values without any danger of overflow. The division by N=64 is not necessary at all; this constant value just changes the scaling of the result (i.e. the scaling binary value to Volt), which has to be considered for any output operation anyway. It doesn't matter to this "consider" which scaling we actually have, it's just another constant to use.<br/>
 What do you need? What do you get?<br/>
 To run this sample you need an Arduino Mega board with the LCD shield connected. Porting this sample to one of the tiny AVRs will be difficult as it requires about 3kByte of RAM and 22 kByte of ROM (in DEBUG configuration). Furthermore, all the 16 ADC inputs are addressed, so functional code modifications would become necessary, too. The sample can be run without the LCD shield as it prints a lot of information to the Arduino console window also (in DEBUG configuration only). The function is as follows: The LCD shield buttons left/right switch to the previous/next ADC input. The internal band gap voltage reference can also be selected as input. The voltage measured at the selected input is continuously displayed on the LCD. Another area of the display displays the current time. (The clock can be adjusted with the buttons up/down.) The last display area shows the current CPU load. All of these areas are continuously updated asynchronously to one another by different tasks.<br/>
 This test case demonstrates the following things:<br/>
 *) The use of a non multi-threading library in a multi-threading environment. The display is purposely accessed by different tasks, which are asynchronous to one another. To do so, the display has been associated with a mutex and each display writing task will acquire the mutex first. All of this has been encapsulated in the class <a class="el" href="classdpy__display__t.html">dpy_display_t</a> and all a task needs to do is calling a simple function printXXX. (Please find more detailed considerations about the use of library LiquidCrystal in the RTuinOS manual.)<br/>
 *) The the input voltage displaying task (taskDisplayVoltage) is regular but not by an RTOS timer operation as usual but because it is associated with the ADC conversion complete interrupt (which is purposely triggered by a regular hardware event). So this part of the application is synchronous to an external event, whereas a concurrent task (taskRTC) is an asynchronous regular task by means of RTuinOS timer operations. Both of these tasks compete for the display without harmful side effects. (The regular timer task implements a real time clock, see <a class="el" href="clk__clock_8cpp.html">clk_clock.cpp</a>.)<br/>
 *) A user interface task scans the buttons, which are mounted on the LCD shield. It decodes the buttons and dispatches the information to the different tasks, which are controlled by the buttons. This part of the code demonstrates how to implement safe inter-task interfaces, mainly built on broadcasted events and critical sections in conjunction with volatile data objects. The interfaces are implemented in both styles, by global, shared data or as functional interface. Priority considerations avoid having superfluous access synchronization code. See code comments for more.<br/>
 *) A totally asynchronous, irregular task also competes for the display. The idle task estimates the CPU load and an associated display task of low priority prints the result on the LCD.<br/>
 *) The source files of this application have purposely been distributed among three folders. Not because this would be the most reasonable folder structure but just to demonstrate how an (optional) application owned makefile fragment can be used to customize RTuinOS' general purpose makefile without the need to change this master makefile. Please inspect tc14.mk to find out. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This test case is no demonstration of an optimal application design. Instead of creating a clear, simple, stable, understandable, maintainable architecture, we tried to put a number of RTOS elements in it to demonstrate and test the capabilities of RTuinOS. Production code would probably look different (and less exciting). </dd>
<dd>
The compilation of this sample requires linkage against the stdio library with floating point support for printf &amp; co. The selection of this library is done in the makefile "callback" into tc14.mk (see above).</dd></dl>
<p>Copyright (C) 2013 Peter Vranken (mailto:<a href="mailto:Peter_Vranken@Yahoo.de">Peter_Vranken@Yahoo.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with this program. If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
<p>Module interface rtos_enableIRQUser00 setup loop Local functions blink taskOnADCComplete taskRTC taskIdleFollower taskButton taskDisplayVoltage </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="aeb7a7ba1ab7e0406f1b5ab36d579f585"></a><!-- doxytag: member="tc14_adcInput.cpp::LED" ref="aeb7a7ba1ab7e0406f1b5ab36d579f585" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LED&#160;&#160;&#160;13</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pin 13 has an LED connected on most Arduino boards. </p>

</div>
</div>
<a class="anchor" id="a4f6d1841b54307e0a38af4f41f1ea128"></a><!-- doxytag: member="tc14_adcInput.cpp::SCALING_BIN_TO_V" ref="a4f6d1841b54307e0a38af4f41f1ea128" args="(binVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCALING_BIN_TO_V</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">binVal</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="adc__analog_input_8h.html#afa1ef3b3ebc99fdc45a640680a659876">ADC_U_REF</a>/(double)((uint32_t)NO_AVERAGED_SAMPLES*<a class="code" href="adc__analog_input_8h.html#a8ff6d55014c9020cad8982ad318d1a7e">ADC_NO_AVERAGED_SAMPLES</a>)/1024.0) \
         *(double)(binVal)                                                                  \
        )
</pre></div>
</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="abc6126af1d45847bc59afa0aa3216b04"></a><!-- doxytag: member="tc14_adcInput.cpp::@3" ref="abc6126af1d45847bc59afa0aa3216b04" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The index to the task objects as needed for requesting the overrun counter or the stack usage. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad146c8310465410fd5600083b174eb00"></a><!-- doxytag: member="tc14_adcInput.cpp::rtos_enableIRQUser00" ref="ad146c8310465410fd5600083b174eb00" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_enableIRQUser00 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The ADC is already configured when this callback is invoked from the RTuinOS kernel initialization code. The callback is just used to release the interrupt on ADC conversion complete - only now the kernel is ready to accept and handle these interrupts. </p>

</div>
</div>
<a class="anchor" id="a4fc01d736fe50cf5b977f755b675f11d"></a><!-- doxytag: member="tc14_adcInput.cpp::setup" ref="a4fc01d736fe50cf5b977f755b675f11d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The initalization of the RTOS tasks and general board initialization. </p>

</div>
</div>
<a class="anchor" id="afe461d27b9c48d5921c00d521181f12f"></a><!-- doxytag: member="tc14_adcInput.cpp::loop" ref="afe461d27b9c48d5921c00d521181f12f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The application owned part of the idle task. This routine is repeatedly called whenever there's some execution time left. It's interrupted by any other task when it becomes due. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Different to all other tasks, the idle task routine may and should return. (The task as such doesn't terminate). This has been designed in accordance with the meaning of the original Arduino loop function. </dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="tc14__adc_input_8cpp.html">tc14_adcInput.cpp</a>      </li>
      <li class="footer">Generated on Mon Aug 26 2013 12:30:20 for RTuinOS by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
