<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RTuinOS: rtos.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RTuinOS&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">Small Scale RTOS for Arduino 1.0.5</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('rtos_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>rtos.c File Reference</h1>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;Arduino.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="rtos__assert_8h_source.html">rtos_assert.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="rtos_8h_source.html">rtos.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a20cc43d0046b2ac33d6880bd621a19c2">IDLE_TASK_ID</a>&#160;&#160;&#160;(RTOS_NO_TASKS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a2c9f885cb9c1e04b5913c24546113c5c">MASK_EVT_IS_SEMAPHORE</a>&#160;&#160;&#160;((0x01&lt;&lt;(RTOS_NO_SEMAPHORE_EVENTS))-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a29bd86112a7cde0637eb62a98b77ca44">MASK_EVT_IS_MUTEX</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a2651e4253fbf0ad048ff5395c4d2c6fc">MASK_EVT_IS_TIMER</a>&#160;&#160;&#160;(RTOS_EVT_ABSOLUTE_TIMER | RTOS_EVT_DELAY_TIMER)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a42b766a4e744a480b8349bc1be22cf1d">UNUSED_STACK_PATTERN</a>&#160;&#160;&#160;0x29</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a7e23ea17d713aa36beef2571a72d177e">PUSH_CONTEXT_ONTO_STACK</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a0bfd1176ef3da1b6a56f8f6346756420">PUSH_CONTEXT_WITHOUT_R24R25_ONTO_STACK</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a775845087a4ea091911dce4173b49377">POP_CONTEXT_FROM_STACK</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#ac884c3a1ef50da2f7c61a3588b54c8f1">SWITCH_CONTEXT</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#ab50466613b5d30ab2e75073e7594c28f">PUSH_RET_CODE_OF_CONTEXT_SWITCH</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RTOS_DEFAULT_FCT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a9aaf9405324cda7deee18d5cb7f6390d">rtos_enableIRQTimerTic</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RTOS_NAKED_FCT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a31394bea21e0b38e390be169f0ee9811">rtos_sendEvent</a> (uint16_t eventVec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RTOS_NAKED_FCT uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#ade4d420d20c378bf3a6fdff59f44126d">rtos_waitForEvent</a> (uint16_t eventMask, boolean all, uintTime_t timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#aa9863feea1785d4d60073a35876e1d5c">ISR</a> (RTOS_ISR_SYSTEM_TIMER_TIC, ISR_NAKED)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a81506c5199c04cdf60ded63c9fa4d120">rtos_getTaskOverrunCounter</a> (uint8_t idxTask, boolean doReset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a54ca7c825941b0d17877db45d2b4c662">rtos_getStackReserve</a> (uint8_t idxTask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a902a2048ccee395d6eec7bd480f8dc01">rtos_initializeTask</a> (uint8_t idxTask, <a class="el" href="rtos_8h.html#a3e12c5d9135209b870ca71628179beb3">rtos_taskFunction_t</a> taskFunction, uint8_t prioClass, uint8_t *const pStackArea, uint16_t stackSize, uint16_t startEventMask, boolean startByAllEvents, uintTime_t startTimeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#ac8b1fae05c844e38b6d93fab56597ce7">rtos_initRTOS</a> (void)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RTOS_PROGMEM_SECTION const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a210d40d5737753d7460f8b0c4ab446d1">rtos_rtuinosStartupMsg</a> [] = &quot;\r&quot; RTOS_RTUINOS_STARTUP_MSG</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#aed225646fe49a53d2a6031c0a99e57cf">_tmpVarAsmToC_u16</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a28dcbedd17c277ec7b25de1694539131">_tmpVarCToAsm_u16</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Implementation of a Real Time Operating System for the Arduino Mega board in the Arduino environment 1.0.5.<br/>
 The implementation is dependent on the board (the controller) and the GNU C++ compiler (thus the release of the Arduino environment) but should be easily portable to other boards and Arduino releases. See manual for details.</p>
<p>Copyright (C) 2012-2013 Peter Vranken (mailto:<a href="mailto:Peter_Vranken@Yahoo.de">Peter_Vranken@Yahoo.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with this program. If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;. </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a20cc43d0046b2ac33d6880bd621a19c2"></a><!-- doxytag: member="rtos.c::IDLE_TASK_ID" ref="a20cc43d0046b2ac33d6880bd621a19c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IDLE_TASK_ID&#160;&#160;&#160;(RTOS_NO_TASKS)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The ID of the idle task. The ID of a task is identical with the index into the task array. </p>

</div>
</div>
<a class="anchor" id="a2c9f885cb9c1e04b5913c24546113c5c"></a><!-- doxytag: member="rtos.c::MASK_EVT_IS_SEMAPHORE" ref="a2c9f885cb9c1e04b5913c24546113c5c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MASK_EVT_IS_SEMAPHORE&#160;&#160;&#160;((0x01&lt;&lt;(RTOS_NO_SEMAPHORE_EVENTS))-1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A bit mask, which selects all the mutex events in an event vector. </p>

</div>
</div>
<a class="anchor" id="a29bd86112a7cde0637eb62a98b77ca44"></a><!-- doxytag: member="rtos.c::MASK_EVT_IS_MUTEX" ref="a29bd86112a7cde0637eb62a98b77ca44" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MASK_EVT_IS_MUTEX</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(((0x0001u&lt;&lt;(<a class="code" href="rtos_8config_8template_8h.html#aeba5a7401c1221fb42082b46c0345519">RTOS_NO_MUTEX_EVENTS</a>+<a class="code" href="rtos_8config_8template_8h.html#a083d99e4e5e9b07eaac67d9a561caf07">RTOS_NO_SEMAPHORE_EVENTS</a>))-1u)    \
         - (uint16_t)<a class="code" href="rtos_8c.html#a2c9f885cb9c1e04b5913c24546113c5c">MASK_EVT_IS_SEMAPHORE</a>                                  \
        )
</pre></div><p>A bit mask, which selects all the mutex events in an event vector. </p>

</div>
</div>
<a class="anchor" id="a2651e4253fbf0ad048ff5395c4d2c6fc"></a><!-- doxytag: member="rtos.c::MASK_EVT_IS_TIMER" ref="a2651e4253fbf0ad048ff5395c4d2c6fc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MASK_EVT_IS_TIMER&#160;&#160;&#160;(RTOS_EVT_ABSOLUTE_TIMER | RTOS_EVT_DELAY_TIMER)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A bit mask, which selects all timer events in a vector of events. </p>

</div>
</div>
<a class="anchor" id="a42b766a4e744a480b8349bc1be22cf1d"></a><!-- doxytag: member="rtos.c::UNUSED_STACK_PATTERN" ref="a42b766a4e744a480b8349bc1be22cf1d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNUSED_STACK_PATTERN&#160;&#160;&#160;0x29</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A pattern byte, which is used as prefill byte of any task stack area. A simple and inexpensive stack usage check at runtime can be implemented by looking for up to where this pattern has been destroyed. Any value which is not the null and which is improbable to be a true stack contents byte can be used - whatever this value might be. </p>

</div>
</div>
<a class="anchor" id="a7e23ea17d713aa36beef2571a72d177e"></a><!-- doxytag: member="rtos.c::PUSH_CONTEXT_ONTO_STACK" ref="a7e23ea17d713aa36beef2571a72d177e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PUSH_CONTEXT_ONTO_STACK</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="rtos_8c.html#a0bfd1176ef3da1b6a56f8f6346756420">PUSH_CONTEXT_WITHOUT_R24R25_ONTO_STACK</a>;         \
    <span class="keyword">asm</span> <span class="keyword">volatile</span>                                    \
    ( <span class="stringliteral">&quot;push r24 \n\t&quot;</span>                               \
      <span class="stringliteral">&quot;push r25 \n\t&quot;</span>                               \
    );
</pre></div><p>An important code pattern, which is used in every interrupt routine, which can result in a context switch. The CPU context except for the program counter is saved by pushing it onto the stack of the given context. The program counter is not explicitly saved: This code pattern needs to be used at the very beginning of a function so that the PC has been pushed onto the stack just before by the call of this function.<br/>
 </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The function which uses this pattern must not be inlined, otherwise the PC would not be part of the saved context and the system would crash when trying to return to this context the next time! </dd>
<dd>
This pattern needs to be changed only in strict accordance with the counterpart pattern, which pops the context from a stack back into the CPU. Both pattern needs to be the inverse of each other. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bfd1176ef3da1b6a56f8f6346756420"></a><!-- doxytag: member="rtos.c::PUSH_CONTEXT_WITHOUT_R24R25_ONTO_STACK" ref="a0bfd1176ef3da1b6a56f8f6346756420" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PUSH_CONTEXT_WITHOUT_R24R25_ONTO_STACK</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An important code pattern, which is used in every suspend command. The CPU context except for the register pair r24/r25 is saved by pushing it onto the stack of the given context. (Exception program counter: see macro <a class="el" href="rtos_8c.html#a7e23ea17d713aa36beef2571a72d177e">PUSH_CONTEXT_ONTO_STACK</a>.)<br/>
 When returning to a context which had become un-due by invoking one of the suspend commands, the restore context should still be done with the other macro <a class="el" href="rtos_8c.html#a775845087a4ea091911dce4173b49377">POP_CONTEXT_FROM_STACK</a>. However, before using this macro, the return code of the suspend command needs to be pushed onto the stack so that it is loaded into the CPU's register pair r24/r25 as part of macro <a class="el" href="rtos_8c.html#a775845087a4ea091911dce4173b49377">POP_CONTEXT_FROM_STACK</a>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The function which uses this pattern must not be inlined, otherwise the PC would not be part of the saved context and the system would crash when trying to return to this context the next time! </dd>
<dd>
This pattern needs to be changed only in strict accordance with the counterpart pattern, which pops the context from a stack back into the CPU. </dd></dl>

</div>
</div>
<a class="anchor" id="a775845087a4ea091911dce4173b49377"></a><!-- doxytag: member="rtos.c::POP_CONTEXT_FROM_STACK" ref="a775845087a4ea091911dce4173b49377" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POP_CONTEXT_FROM_STACK</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An important code pattern, which is used in every interrupt routine (including the suspend commands, which can be considered pseudo-software interrupts). The CPU context except for the program counter is restored by popping it from the stack of the given context. The program counter is not popped: This code pattern needs to be used at the very end of a function so that the PC will be restored by the machine return command (ret or reti).<br/>
 </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The function which uses this pattern must not be inlined, otherwise the PC would not be part of the restored context and the system would crash. </dd>
<dd>
This pattern needs to be changed only in strict accordance with the counterpart patterns, which push the context onto the stack. The pattern need to be the inverse of each other. </dd></dl>

</div>
</div>
<a class="anchor" id="ac884c3a1ef50da2f7c61a3588b54c8f1"></a><!-- doxytag: member="rtos.c::SWITCH_CONTEXT" ref="ac884c3a1ef50da2f7c61a3588b54c8f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SWITCH_CONTEXT</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{                                                                                           \
    <span class="comment">/* Switch the stack pointer to the (saved) stack pointer of the new active task. */</span>     \
    <a class="code" href="rtos_8c.html#a28dcbedd17c277ec7b25de1694539131">_tmpVarCToAsm_u16</a> = _pActiveTask-&gt;stackPointer;                                         \
    <span class="keyword">asm</span> <span class="keyword">volatile</span>                                                                            \
    ( <span class="stringliteral">&quot;in r0, __SP_L__ /* Save current stack pointer at known, fixed location */ \n\t&quot;</span>      \
      <span class="stringliteral">&quot;sts _tmpVarAsmToC_u16, r0 \n\t&quot;</span>                                                      \
      <span class="stringliteral">&quot;in r0, __SP_H__ \n\t&quot;</span>                                                                \
      <span class="stringliteral">&quot;sts _tmpVarAsmToC_u16+1, r0 \n\t&quot;</span>                                                    \
      <span class="stringliteral">&quot;lds r0, _tmpVarCToAsm_u16 \n\t&quot;</span>                                                      \
      <span class="stringliteral">&quot;out __SP_L__, r0 /* Write l-byte of new stack pointer content */ \n\t&quot;</span>               \
      <span class="stringliteral">&quot;lds r0, _tmpVarCToAsm_u16+1 \n\t&quot;</span>                                                    \
      <span class="stringliteral">&quot;out __SP_H__, r0 /* Write h-byte of new stack pointer content */ \n\t&quot;</span>               \
    );                                                                                      \
    _pSuspendedTask-&gt;stackPointer = <a class="code" href="rtos_8c.html#aed225646fe49a53d2a6031c0a99e57cf">_tmpVarAsmToC_u16</a>;                                      \
                                                                                            \
}
</pre></div><p>An important code pattern, which is used in every interrupt routine (including the suspend commands, which can be considered pseudo-software interrupts). The code performs the actual task switch by saving the current stack pointer in a location owned by the left task and by loading the stack pointer from a location owned by the new task (where its stack pointer value had been saved at initialization time or the last time it became inactive).<br/>
 Side effects: The left task and the new task are read from the global variables _pSuspendedTask and _pActiveTask.<br/>
 Prerequisites: The use of the macro needs to be followed by a use of macro PUSH_RET_CODE_OF_SWITCH_CONTEXT.<br/>
 The routine depends on a reset global interrupt flag.<br/>
 The implementation must be compatible with a naked function. In particular, it must not define any local data! </p>

</div>
</div>
<a class="anchor" id="ab50466613b5d30ab2e75073e7594c28f"></a><!-- doxytag: member="rtos.c::PUSH_RET_CODE_OF_CONTEXT_SWITCH" ref="ab50466613b5d30ab2e75073e7594c28f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PUSH_RET_CODE_OF_CONTEXT_SWITCH</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An important code pattern, which is used in every interrupt routine (including the suspend commands, which can be considered pseudo-software interrupts). Placed immediately after a context switch, the code fragment decides whether the task we switch to had been inactivated by a timer or application interrupt or by a suspend command. (Only) in the latter case the return value of the suspend command is put onto the stack. From there it'll be loaded into the CPU when ending the interrupt routine.<br/>
 Side effects: The new task is read from the global variable _pActiveTask.<br/>
 Prerequisites: The use of the macro needs to be preceded by a use of macro SWITCH_CONTEXT.<br/>
 The routine depends on a reset global interrupt flag.<br/>
 The implementation must be compatible with a naked function. In particular, it must not define any local data! </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a9aaf9405324cda7deee18d5cb7f6390d"></a><!-- doxytag: member="rtos.c::rtos_enableIRQTimerTic" ref="a9aaf9405324cda7deee18d5cb7f6390d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTOS_DEFAULT_FCT void rtos_enableIRQTimerTic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start the interrupt which clocks the system time. Timer 2 is used as interrupt source with a period time of about 2 ms or a frequency of 490.1961 Hz respectively.<br/>
 This is the default implementation of the routine, which can be overloaded by the application code if another interrupt or other interrupt settings should be used. </p>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>It is also possible to do specific initialization of any other available timer here and to enable the related interrupt. In which case you have to alter the name of the interrupt vector in use. Modify <a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#ad4a77dc2ff9b06fc8e39ed35e768c0ae">RTOS_ISR_SYSTEM_TIMER_TIC</a> to do so. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="a31394bea21e0b38e390be169f0ee9811"></a><!-- doxytag: member="rtos.c::rtos_sendEvent" ref="a31394bea21e0b38e390be169f0ee9811" args="(uint16_t eventVec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTOS_NAKED_FCT void rtos_sendEvent </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>eventVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A task (including the idle task) may post an event. The event is broadcasted to all suspended tasks which are waiting for it. An event is not saved beyond that. If a task suspends and starts waiting for an event which has been posted by another task just before, it'll wait forever and never be resumed.<br/>
 The posted event may resume another task, which may be of higher priority as the event posting task. In this case <em>sendEvent</em> will cause a task switch. The calling task stays due but stops to be the active task. It does not become suspended (this is why even the idle task may call this function). The activated task will resume by coming out of the suspend command it had been invoked to wait for this event. The return value of this suspend command will then tell about the event set here.<br/>
 If no task of higher priority is resumed by the posted event the calling task will be continued immediately after execution of this method. In this case <em>sendEvent</em> behaves like any ordinary sub-routine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">eventVec</td><td>A bit vector of posted events. Known events are defined in <a class="el" href="rtos_8h.html">rtos.h</a>. The timer events RTOS_EVT_ABSOLUTE_TIMER and RTOS_EVT_DELAY_TIMER cannot be posted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>uint16_t <a class="el" href="rtos_8h.html#a4758bc6137ec6a49b6c587403f7a0f17">rtos_waitForEvent(uint16_t, boolean, uintTime_t)</a> </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>It is absolutely essential that this routine is implemented as naked and noinline. See <a href="http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html">http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html</a> for details </dd>
<dd>
In optimization level 0 GCC has a problem with code generation for naked functions. See function <a class="el" href="rtos_8h.html#a91e2be2c71d5ee6619b3cf069c49f18f">rtos_suspendTaskTillTime</a> for details. </dd>
<dd>
The implementation of this function is reused on machine code level by the implementation of the application interrupt service routines <em>ISR(RTOS_ISR_USER_nn)</em>. This function needs to be maintained in strict accordance with the implementation of the ISRs. </dd></dl>

</div>
</div>
<a class="anchor" id="ade4d420d20c378bf3a6fdff59f44126d"></a><!-- doxytag: member="rtos.c::rtos_waitForEvent" ref="ade4d420d20c378bf3a6fdff59f44126d" args="(uint16_t eventMask, boolean all, uintTime_t timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTOS_NAKED_FCT uint16_t rtos_waitForEvent </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>eventMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintTime_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Suspend the current task (i.e. the one which invokes this method) until a specified combination of events occur. In the special case, that the specified combination of events can be satisfied with currently available synchronization objects (mutexes and semaphores) the function will return immediately without suspending the calling task.<br/>
 A task is suspended in the instance of calling this method. It specifies a list of events. The task becomes due again, when either the first one or all of the specified events have been posted by other tasks.<br/>
 The idle task can't be suspended. If it calls this function a crash would be the immediate result. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The set of actually resuming events is returned as a bit vector which corresponds bitwise to eventMask. See <em><a class="el" href="rtos_8h.html">rtos.h</a></em> for a list of known events. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">eventMask</td><td>The bit vector of events to wait for. Needs to include either the delay timer event <a class="el" href="rtos_8h.html#ad1826c27715466493d50f3266ecd9cd9">RTOS_EVT_DELAY_TIMER</a> or <a class="el" href="rtos_8h.html#a2c10db7141dcec5eeb56c29cd0ac5fe8">RTOS_EVT_ABSOLUTE_TIMER</a>, if a timeout is required, but not both of them.<br/>
 The normal use case will probably be the delay timer. However, a regular task may also specify the absolute timer with the next regular task time as parameter so that it surely becomes due outermost at its usual task time. </td></tr>
    <tr><td class="paramname">all</td><td>If false, the task is made due as soon as the first event mentioned in <em>eventMask</em> is seen.<br/>
 If true, the task is made due only when all events are posted to the suspending task - except for the timer events, which are still OR combined. If you say "all" but the event mask contains either <a class="el" href="rtos_8h.html#ad1826c27715466493d50f3266ecd9cd9">RTOS_EVT_DELAY_TIMER</a> or <a class="el" href="rtos_8h.html#a2c10db7141dcec5eeb56c29cd0ac5fe8">RTOS_EVT_ABSOLUTE_TIMER</a>, the task will resume when either the timer elapsed or when all other events in the mask were seen.<br/>
 Caution: If all is true, there need to be at least one event bit set in <em>eventMask</em> besides a timer bit; RTuinOS crashes otherwise. Saying: "No particular event, just a
 timer condition" needs to be implemented by <em>all</em> set to false and <em>eventMask</em> set to only a timer event bit. </td></tr>
    <tr><td class="paramname">timeout</td><td>If <em>eventMask</em> contains <a class="el" href="rtos_8h.html#ad1826c27715466493d50f3266ecd9cd9">RTOS_EVT_DELAY_TIMER</a>:<br/>
 The number of system timer tics from now on until the timeout elapses. One should be aware of the resolution of any timing being the tic of the system timer. A timeout of <em>n</em> may actually mean any delay in the range <em>n</em> .. <em>n+1</em> tics.<br/>
 Even specifying 0 will suspend the task a short time and give others the chance to become active - particularly other tasks belonging to the same priority class.<br/>
 If <em>eventMask</em> contains <a class="el" href="rtos_8h.html#a2c10db7141dcec5eeb56c29cd0ac5fe8">RTOS_EVT_ABSOLUTE_TIMER</a>:<br/>
 The absolute time the task becomes due again at latest. The time designation is relative; it refers to the last recent absolute time at which this task had been resumed. See <a class="el" href="rtos_8h.html#a91e2be2c71d5ee6619b3cf069c49f18f">rtos_suspendTaskTillTime</a> for details.<br/>
 Now the range of the parameter is 1 till the half the range of the data type which is configured for the system time, e.g. 127 in case of uint8_t. Otherwise proper task timing can't be guaranteed.<br/>
 If neither <a class="el" href="rtos_8h.html#ad1826c27715466493d50f3266ecd9cd9">RTOS_EVT_DELAY_TIMER</a> nor <a class="el" href="rtos_8h.html#a2c10db7141dcec5eeb56c29cd0ac5fe8">RTOS_EVT_ABSOLUTE_TIMER</a> is set in the event mask, this parameter should be zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9863feea1785d4d60073a35876e1d5c"></a><!-- doxytag: member="rtos.c::ISR" ref="aa9863feea1785d4d60073a35876e1d5c" args="(RTOS_ISR_SYSTEM_TIMER_TIC, ISR_NAKED)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ISR </td>
          <td>(</td>
          <td class="paramtype">RTOS_ISR_SYSTEM_TIMER_TIC&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISR_NAKED&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Each call of this function cyclically increments the system time of the kernel by one.<br/>
 Incrementing the system timer is an important system event. The routine will always include an inspection of all suspended tasks, whether they could become due again. The cycle time of the system time is low (typically implemented as 0..255) and determines the maximum delay time or timeout for a task which suspends itself and the ratio of the task periods of the fastest and the slowest regular task. Furthermore it determines the reliability of task overrun recognition. Task overrun events in the magnitude of half the cycle time won't be recognized as such.<br/>
 The unit of the time is defined only by the it triggering source and doesn't matter at all for the kernel. The time even don't need to be regular.<br/>
 </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The function needs to be called by an interrupt and can easily end with a context change, i.e. the interrupt will return to another task as the one it had interrupted. </dd>
<dd>
The connected interrupt is defined by macro <a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#ad4a77dc2ff9b06fc8e39ed35e768c0ae">RTOS_ISR_SYSTEM_TIMER_TIC</a>. This interrupt needs to be disabled/enabled by the implementation of <em>enterCriticalSection</em> and <em>leaveCriticalSection</em>. </dd>
<dd>
The cycle time of the system time can be influenced by the typedef of uintTime_t. Find a discussion of pros and cons at the location of this typedef. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>boolean onTimerTic(void) </dd>
<dd>
<a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#acf24026fc76a744b3bfeb63b9277cb58">rtos_enterCriticalSection</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a81506c5199c04cdf60ded63c9fa4d120"></a><!-- doxytag: member="rtos.c::rtos_getTaskOverrunCounter" ref="a81506c5199c04cdf60ded63c9fa4d120" args="(uint8_t idxTask, boolean doReset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rtos_getTaskOverrunCounter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idxTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>doReset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the current value of the overrun counter of a given task.<br/>
 The value is a limited 8 Bit counter (i.e. it won't cycle around). This is considered satisfying as any task overrun is a kind of error and should not happen in a real application (with other words: even a Boolean information could be enough). Furthermore, if a larger range is required, one can regularly ask for this information, accumulate it and reset the value here to zero at the same time.<br/>
 The function may be called from a task or from the idle task. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the current value of the overrun counter. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">idxTask</td><td>The index of the task the overrun counter of which is to be returned. The index is the same as used when initializing the tasks (see rtos_initializeTask). </td></tr>
    <tr><td class="paramname">doReset</td><td>Boolean flag, which tells whether to reset the value.<br/>
 Caution, when setting this to true, reading and resetting the value needs to become an atomic operation, which requires a critical section. This is significantly more expensive than just reading the value and it globally enables the interrupts finally. Therefore this call may destroy a surrounding critical section. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function has some limitations and weaknesses: First of all, the concept of task overruns is defined only for regular tasks. Secondary, and particularly when using the 8 Bit system timer, there's a significant probability of not recognizing huge task overruns. Finally there's a significant probability of false recognitions of (not happening) task overruns if the task period time is greater than half the system timer's cycle time (i.e. greater than 127 for the 8 Bit system timer). Please, refer to the RTuinOS manual for details. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="rtos_8c.html#a902a2048ccee395d6eec7bd480f8dc01">rtos_initializeTask()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a54ca7c825941b0d17877db45d2b4c662"></a><!-- doxytag: member="rtos.c::rtos_getStackReserve" ref="a54ca7c825941b0d17877db45d2b4c662" args="(uint8_t idxTask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rtos_getStackReserve </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idxTask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute how many bytes of the stack area of a task are still unused. If the value is requested after an application has been run a long while and has been forced to run through all its paths many times, it may be used to optimize the static stack allocation of the task. The function is useful only for diagnosis purpose as there's no chance to dynamically increase or decrease the stack area at runtime.<br/>
 The function may be called from a task or from the idle task.<br/>
 The algorithm is as follows: The unused part of the stack is initialized with a specific pattern byte. This routine counts the number of subsequent pattern bytes down from the top of the stack area. This number is returned.<br/>
 The returned result must not be trusted too much: It could of course be that a pattern byte is found not because of the initialization but because it has been pushed onto the stack - in which case the return value is too great (too optimistic) by one. The probability that this happens is significantly greater than zero. The chance that two pattern bytes had been pushed is however much less and the probability of three, four, five such bytes in sequence is negligible. (Except the irrelevant case you initialize an automatic array variable with all pattern bytes.) Any stack size optimization based on this routine should therefore subtract e.g. five bytes from the returned reserve and diminish the stack outermost by this modified value.<br/>
 Be careful with stack size optimization based on this routine: Even if the application ran a long time there's a non-zero probability that there has not yet been a system timer interrupt in the very instance that the code of the task of interest was busy in the deepest nested sub-routine, i.e. when having the largest stack consumption. A good suggestion is to have another 36 Byte of reserve - this is the stack consumption if an interrupt occurs.<br/>
 Recipe: Run your application a long time, ensure that it ran through all paths, get the stack reserve from this routine, subtract 5+36 Byte and diminish the stack by this value. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of still unused stack bytes. See function description for details. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">idxTask</td><td>The index of the task the stack usage has to be investigated for. The index is the same as used when initializing the tasks (see rtos_initializeTask). </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The computation is a linear search for the first non-pattern byte and thus relatively expensive. It's suggested to call it only in some specific diagnosis compilation or occasionally from the idle task. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="rtos_8c.html#a902a2048ccee395d6eec7bd480f8dc01">rtos_initializeTask()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a902a2048ccee395d6eec7bd480f8dc01"></a><!-- doxytag: member="rtos.c::rtos_initializeTask" ref="a902a2048ccee395d6eec7bd480f8dc01" args="(uint8_t idxTask, rtos_taskFunction_t taskFunction, uint8_t prioClass, uint8_t *const pStackArea, uint16_t stackSize, uint16_t startEventMask, boolean startByAllEvents, uintTime_t startTimeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_initializeTask </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idxTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rtos_8h.html#a3e12c5d9135209b870ca71628179beb3">rtos_taskFunction_t</a>&#160;</td>
          <td class="paramname"><em>taskFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prioClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pStackArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>startEventMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>startByAllEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintTime_t&#160;</td>
          <td class="paramname"><em>startTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the contents of a single task object.<br/>
 This routine needs to be called from within <a class="el" href="tc07__critical_section_8c.html#a7dfd9b79bc5a37d7df40207afbc5431f">setup()</a> once for each task. The number of tasks has been defined by the application using <a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#a9375e1b99d1360af097706deed2dd957">RTOS_NO_TASKS</a> but the array of this number of task objects is still empty. The system will crash if this routine is not called properly for each of the tasks before the RTOS actually starts.<br/>
 This function must never be called outside of <a class="el" href="tc07__critical_section_8c.html#a7dfd9b79bc5a37d7df40207afbc5431f">setup()</a>. A crash would result otherwise. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">idxTask</td><td>The index of the task in the range 0..RTOS_NO_TASKS-1. The order of tasks barely matters. </td></tr>
    <tr><td class="paramname">taskFunction</td><td>The task function as a function pointer. It is used once and only once: The task function is invoked the first time the task becomes active and must never end. A return statement would cause an immediate reset of the controller. </td></tr>
    <tr><td class="paramname">prioClass</td><td>The priority class this task belongs to. Priority class 255 has the highest possible priority and the lower the value the lower the priority. </td></tr>
    <tr><td class="paramname">timeRoundRobin</td><td>The maximum time a task may be activated if it is operated in round-robin mode. The range is 1..max_value(<em>uintTime_t</em>).<br/>
 Specify a maximum time of 0 to switch round robin mode off for this task.<br/>
 Remark: Round robin like behavior is given only if there are several tasks in the same priority class and all tasks of this class have the round-robin mode activated. Otherwise it's just the limitation of execution time for an individual task.<br/>
 This parameter is available only if <a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#a40d0df06f67d8a73574879217d9ea34c">RTOS_ROUND_ROBIN_MODE_SUPPORTED</a> is set to <a class="el" href="rtos_8h.html#af0db50dba4d0026d470641610de9b624">RTOS_FEATURE_ON</a>. </td></tr>
    <tr><td class="paramname">pStackArea</td><td>The pointer to the preallocated stack area of the task. The area needs to be available all the RTOS runtime. Therefore dynamic allocation won't pay off. Consider to use the address of any statically defined array. There's no alignment constraint. </td></tr>
    <tr><td class="paramname">stackSize</td><td>The size in Byte of the memory area <em>*pStackArea</em>, which is reserved as stack for the task. Each task may have an individual stack size. </td></tr>
    <tr><td class="paramname">startEventMask</td><td>The condition under which the task becomes due the very first time is specified nearly in the same way as at runtime when using the suspend command <em>rtos_waitForEvent:</em> A set of events to wait for is specified, the Boolean information if any event will activate the task or if all are required and finally a timeout in case no such events would be posted.<br/>
 This parameter specifies the set of events as a bit vector. Only ordinary events are supports, i.e. braodcasted events. Events of kind mutex or semaphore must not be used here. If a task needs to own such events right from beginning its implementation needs to place an explicit suspend command <em>rtos_waitForEvent</em> as very first command. </td></tr>
    <tr><td class="paramname">startByAllEvents</td><td>If true, all specified events (except for a timer event) must be posted before the task is activated. Otherwise the first event belonging to the specified set will activate the task. See rtos_waitForEvent for details. </td></tr>
    <tr><td class="paramname">startTimeout</td><td>The task will be started at latest after <em>startTimeout</em> system timer tics if only the event <a class="el" href="rtos_8h.html#ad1826c27715466493d50f3266ecd9cd9">RTOS_EVT_DELAY_TIMER</a> is in the set of specified events. If none of the timer events <a class="el" href="rtos_8h.html#ad1826c27715466493d50f3266ecd9cd9">RTOS_EVT_DELAY_TIMER</a> and <a class="el" href="rtos_8h.html#a2c10db7141dcec5eeb56c29cd0ac5fe8">RTOS_EVT_ABSOLUTE_TIMER</a> are set in <em>startEventMask</em>, the task will not be activated by a time condition. Do not set both timer events at once! See rtos_waitForEvent for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="rtos_8h.html#ac8b1fae05c844e38b6d93fab56597ce7">rtos_initRTOS(void)</a> </dd>
<dd>
uint16_t <a class="el" href="rtos_8h.html#a4758bc6137ec6a49b6c587403f7a0f17">rtos_waitForEvent(uint16_t, boolean, uintTime_t)</a> </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The restriction that the initial resume condition must not comprise the request for mutex or semaphore kind of events has been made just for simplicity. No additional code is needed for broadcasted events but would be needed to allow mutexes and semaphores, too.<br/>
 The main use case for the start condition is to delay the take off of different tasks by individual time spans to avoid having too many regular tasks becoming due at the same timer tic. If there should be a use case for initial waiting for a mutex or semaphore this can be easily implemented by an according suspend command at the beginning of the actual task code. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8b1fae05c844e38b6d93fab56597ce7"></a><!-- doxytag: member="rtos.c::rtos_initRTOS" ref="ac8b1fae05c844e38b6d93fab56597ce7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_initRTOS </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Application called initialization of RTOS.<br/>
 Most important is the application handled task information. A task is characterized by several static settings which need to be preset by the application. To save resources, a standard situation will be the specification of all relevant settings at compile time in the initializer expression of the array definition. The array is declared extern to enable this mode.<br/>
 The application however also has the chance to provide this information at runtime. Early in the execution of this function a callback <em>setup</em> into the application is invoked. If the application has setup everything as a compile time expression, the callback may simply contain a return.<br/>
 The callback <em>setup</em> is invoked before any RTOS related interrupts have been initialized, the routine is executed in the same context as and as a substitute of the normal Arduino setup routine. The implementation can be made without bothering with interrupt inhibition or data synchronization considerations. Furthermore it can be used for all the sort of things you've ever done in Arduino's setup routine.<br/>
 After returning from <em>setup</em> all tasks defined in the task array are made due. The main interrupt, which clocks the RTOS system time is started and will immediately make the very task the active task which belongs to the highest priority class and which was found first (i.e. in the order of rising indexes) in the task array. The system is running.<br/>
 No idle task is specified in the task array. The idle task is implicitly defined and implemented as the external function <em>loop</em>. To stick to Arduino's convention (and to give the RTOS the chance to benefit from idle as well) <em>loop</em> is still implemented as such: You are encouraged to return from <em>loop</em> after doing things. RTOS will call <em>loop</em> again as soon as it has some time left.<br/>
 As for the original Arduino code, <em>setup</em> and <em>loop</em> are mandatory, global functions.<br/>
 This routine is not called by the application but in C's main function. Your code seems to start with setup and seems then to branch into either <em>loop</em> (the idle task) or any other of the tasks defined by your application.<br/>
 This function never returns. No task must ever return, a reset will be the immediate consequence. Your part of the idle task, function <em>loop</em>, may and should return, but the actual idle task as a whole won't terminate neither. Instead it'll repeat to call <em>loop</em>. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a210d40d5737753d7460f8b0c4ab446d1"></a><!-- doxytag: member="rtos.c::rtos_rtuinosStartupMsg" ref="a210d40d5737753d7460f8b0c4ab446d1" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTOS_PROGMEM_SECTION const char <a class="el" href="rtos_8h.html#a210d40d5737753d7460f8b0c4ab446d1">rtos_rtuinosStartupMsg</a>[] = &quot;\r&quot; RTOS_RTUINOS_STARTUP_MSG</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The RTuinOS startup message is placed in the flash ROM. Here, memory is not expensive. Consider to use <em>Serial.println</em> or <em>puts_progmem</em> to print such a string in the Arduino console window. Or Please refer to <a class="el" href="tc12_2stdout_8c.html">tc12/stdout.c</a>, test case tc12, for more.<br/>
 See <a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=34734">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=34734</a> why not using PROGMEM for the declaration and <a class="el" href="rtos_8h.html#a230d90f46eaeeabc20cac6e3eda61f8e">RTOS_PROGMEM_SECTION</a> for a valid substitute. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>int <a class="el" href="tc14_2rtos_config_2stdout_8h.html#a2333df38040d879e79ea55017096d1ea">puts_progmem(const char *)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aed225646fe49a53d2a6031c0a99e57cf"></a><!-- doxytag: member="rtos.c::_tmpVarAsmToC_u16" ref="aed225646fe49a53d2a6031c0a99e57cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint16_t <a class="el" href="rtos_8c.html#aed225646fe49a53d2a6031c0a99e57cf">_tmpVarAsmToC_u16</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Temporary data, internally used to pass information between assembly and C code. </p>

</div>
</div>
<a class="anchor" id="a28dcbedd17c277ec7b25de1694539131"></a><!-- doxytag: member="rtos.c::_tmpVarCToAsm_u16" ref="a28dcbedd17c277ec7b25de1694539131" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint16_t <a class="el" href="rtos_8c.html#a28dcbedd17c277ec7b25de1694539131">_tmpVarCToAsm_u16</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Temporary data, internally used to pass information between C and assembly code. </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="rtos_8c.html">rtos.c</a>      </li>
      <li class="footer">Generated on Mon Aug 26 2013 12:30:19 for RTuinOS by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
