<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RTuinOS: rtos.config.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RTuinOS&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">Small Scale RTOS for Arduino 1.0.5</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('tc14_2rtos_config_2rtos_8config_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<h1>tc14/rtosConfig/rtos.config.h File Reference</h1>  </div>
</div>
<div class="contents">

<p><a href="tc14_2rtos_config_2rtos_8config_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#a40d0df06f67d8a73574879217d9ea34c">RTOS_ROUND_ROBIN_MODE_SUPPORTED</a>&#160;&#160;&#160;RTOS_FEATURE_OFF</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#a9375e1b99d1360af097706deed2dd957">RTOS_NO_TASKS</a>&#160;&#160;&#160;5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#af6fb3b8687c96685e1ee4e62f4e16c9a">RTOS_NO_PRIO_CLASSES</a>&#160;&#160;&#160;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#ab1d58580bc9cce69a399d6237121b628">RTOS_MAX_NO_TASKS_IN_PRIO_CLASS</a>&#160;&#160;&#160;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#a083d99e4e5e9b07eaac67d9a561caf07">RTOS_NO_SEMAPHORE_EVENTS</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#aeba5a7401c1221fb42082b46c0345519">RTOS_NO_MUTEX_EVENTS</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#ad4a77dc2ff9b06fc8e39ed35e768c0ae">RTOS_ISR_SYSTEM_TIMER_TIC</a>&#160;&#160;&#160;TIMER2_OVF_vect</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#add5b23832c4b645c4425272e9b74064b">RTOS_TIC</a>&#160;&#160;&#160;(2.04e-3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#a5e0fdba99bbc77534b5543411c74bf66">RTOS_USE_APPL_INTERRUPT_00</a>&#160;&#160;&#160;RTOS_FEATURE_ON</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#aa45ffbc5d63a6d4abf52d4630acf7990">RTOS_ISR_USER_00</a>&#160;&#160;&#160;ADC_vect</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#a9c1a5203784dfef032e71987acd938e4">RTOS_USE_APPL_INTERRUPT_01</a>&#160;&#160;&#160;RTOS_FEATURE_OFF</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#ae58e83719197ede9e06180f7e7f02e2a">RTOS_ISR_USER_01</a>&#160;&#160;&#160;xxx_vect</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#aaa4a8fd0247c89f3d56a45f78893bcec">RTOS_DEFINE_TYPE_OF_SYSTEM_TIME</a>(noBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#acf24026fc76a744b3bfeb63b9277cb58">rtos_enterCriticalSection</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#a7a560f736b13c931bee8c498fa0f32d3">rtos_leaveCriticalSection</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#aea4eba3e53ed9ad5ac0439a3fd3f4ced">RTOS_DEFINE_TYPE_OF_SYSTEM_TIME_DOXYGEN_TAG</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#ad9d2183f5770c62869b0716c3bdfab83">RTOS_OVERRUN_TASK_IS_IMMEDIATELY_DUE</a>&#160;&#160;&#160;RTOS_FEATURE_ON</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#a7f77cb42f6112e1647ce7307a910aeba">uintSemaphore_t</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Switches to define the most relevant compile-time settings of RTuinOS in an application specific way.</p>
<p>Copyright (C) 2012-2013 Peter Vranken (mailto:<a href="mailto:Peter_Vranken@Yahoo.de">Peter_Vranken@Yahoo.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with this program. If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;. </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a40d0df06f67d8a73574879217d9ea34c"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::RTOS_ROUND_ROBIN_MODE_SUPPORTED" ref="a40d0df06f67d8a73574879217d9ea34c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ROUND_ROBIN_MODE_SUPPORTED&#160;&#160;&#160;RTOS_FEATURE_OFF</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Does the task scheduling concept support time slices of limited length for activated tasks? If on, the overhead of the scheduler slightly increases.<br/>
 Select either RTOS_FEATURE_OFF or RTOS_FEATURE_ON. </p>

</div>
</div>
<a class="anchor" id="a9375e1b99d1360af097706deed2dd957"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::RTOS_NO_TASKS" ref="a9375e1b99d1360af097706deed2dd957" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_NO_TASKS&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of tasks in the system. Tasks aren't created dynamically. This number of tasks will always be existent and alive. Permitted range is 0..127.<br/>
 A runtime check is not done. The code will crash in case of a bad setting. </p>

</div>
</div>
<a class="anchor" id="af6fb3b8687c96685e1ee4e62f4e16c9a"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::RTOS_NO_PRIO_CLASSES" ref="af6fb3b8687c96685e1ee4e62f4e16c9a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_NO_PRIO_CLASSES&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of distinct priorities of tasks. Since several tasks may share the same priority, this number is lower or equal to NO_TASKS. Permitted range is 0..NO_TASKS, but 1..NO_TASKS if at least one task is defined.<br/>
 A runtime check is not done. The code will crash in case of a bad setting. </p>

</div>
</div>
<a class="anchor" id="ab1d58580bc9cce69a399d6237121b628"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::RTOS_MAX_NO_TASKS_IN_PRIO_CLASS" ref="ab1d58580bc9cce69a399d6237121b628" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_MAX_NO_TASKS_IN_PRIO_CLASS&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Since many tasks will belong to distinct priority classes, the maximum number of tasks belonging to the same class will be significantly lower than the number of tasks. This setting is used to reduce the required memory size for the statically allocated data structures. Set the value as low as possible. Permitted range is min(1, NO_TASKS)..127, but a value greater than NO_TASKS is not reasonable.<br/>
 A runtime check is not done. The code will crash in case of a bad setting. </p>

</div>
</div>
<a class="anchor" id="a083d99e4e5e9b07eaac67d9a561caf07"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::RTOS_NO_SEMAPHORE_EVENTS" ref="a083d99e4e5e9b07eaac67d9a561caf07" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_NO_SEMAPHORE_EVENTS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The number of events, which behave like semaphores. When posted, they are not broadcasted like ordinary events but posted to only one task, which is the one of highest priority, which is currently waiting for this event. If no such task exists, the semaphore-event is counted in the related semaphore for future requests of the semaphore by any task.<br/>
 Having semaphores in the application increases the overhead of RTuinOS significantly. The number should be null as long as semaphores are not essential to the application. In particular, one should not use semaphores where mutexes are possible. Mutexes are a sub-set of semaphores; it are semaphores with start value one and they can be implemented much more efficient by bit operations. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>To reduce the cost of the implementation of semaphores RTuinOS restricts the number of semaphores to eight out of the 16 events.<br/>
 </dd>
<dd>
Two additional things have to be configured, when using at least one semaphore in your application:<br/>
 All semaphores are implemented as unsigned integers of a given type. The type determines the counting range of the semaphores and is application dependent. Please, see below for the application owned typedef <em>uintSemaphore_t</em>.<br/>
 The use case of a semaphore pre-determines its initial value. To make it most easy and efficient for the application the array of semaphores is declared extern to RTuinOS. Please refer to <a class="el" href="rtos_8h.html">rtos.h</a> for the declaration of <em>rtos_semaphoreAry</em> and define <b>and</b> <b>initialize</b> this array in your application code. </dd></dl>

</div>
</div>
<a class="anchor" id="aeba5a7401c1221fb42082b46c0345519"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::RTOS_NO_MUTEX_EVENTS" ref="aeba5a7401c1221fb42082b46c0345519" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_NO_MUTEX_EVENTS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The number of events, which behave like mutexes. When posted, they are not broadcasted like ordinary events but posted to only one task, which is the one of highest priority, which is currently waiting for this event. If no such task exists, the mutex-event is saved until the first task requests it. Having mutexes in the application increases the overhead of RTuinOS. It should be null as long as mutexes are not essential to the application. </p>

</div>
</div>
<a class="anchor" id="ad4a77dc2ff9b06fc8e39ed35e768c0ae"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::RTOS_ISR_SYSTEM_TIMER_TIC" ref="ad4a77dc2ff9b06fc8e39ed35e768c0ae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ISR_SYSTEM_TIMER_TIC&#160;&#160;&#160;TIMER2_OVF_vect</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Select the interrupt which clocks the system time. Side effects to consider: This interrupt (like all others which possibly result in a context switch) need to be inhibited by rtos_enterCriticalSection.<br/>
 If an application redefines the interrupt source, it'll probably have to implement the code to configure this interrupt (e.g. set the interrupt enable bit in the according peripheral). If so, this needs to be done by reimplementing void <a class="el" href="rtos_8h.html#ad1c5008c324111a1df14ff7e7ae341da">rtos_enableIRQTimerTic(void)</a>, which is an overridable default implementation.<br/>
 If an application redefines the interrupt source, the new source will probably produce another system clock frequency. If so, the macro <a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#add5b23832c4b645c4425272e9b74064b">RTOS_TIC</a> needs to be redefined also. </p>

</div>
</div>
<a class="anchor" id="add5b23832c4b645c4425272e9b74064b"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::RTOS_TIC" ref="add5b23832c4b645c4425272e9b74064b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_TIC&#160;&#160;&#160;(2.04e-3)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The system timer tic is about 2 ms. For more accurate considerations, it is defined here as floating point constant. The unit is s. </p>

</div>
</div>
<a class="anchor" id="a5e0fdba99bbc77534b5543411c74bf66"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::RTOS_USE_APPL_INTERRUPT_00" ref="a5e0fdba99bbc77534b5543411c74bf66" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_USE_APPL_INTERRUPT_00&#160;&#160;&#160;RTOS_FEATURE_ON</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable the application defined interrupt 0. (Two such interrupts are pre-configured in the code and more can be implemented by taking these two as a code template.)<br/>
 To install an application interrupt, this define is set to <a class="el" href="rtos_8h.html#af0db50dba4d0026d470641610de9b624">RTOS_FEATURE_ON</a>.<br/>
 Secondary, you will define <a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#aa45ffbc5d63a6d4abf52d4630acf7990">RTOS_ISR_USER_00</a> in order to specify the interrupt source.<br/>
 Then, you will implement the callback <em><a class="el" href="tc14__adc_input_8cpp.html#ad146c8310465410fd5600083b174eb00">rtos_enableIRQUser00(void)</a></em> which enables the interrupt, typically by accessing the interrupt control register of some peripheral.<br/>
 Now the interrupt is enabled and if it occurs it'll post the event #RTOS_EVT_ISR_USER_00. You will probably have a task of high priority which is waiting for this event in order to handle the interrupt when it is resumed by the event. </p>

</div>
</div>
<a class="anchor" id="aa45ffbc5d63a6d4abf52d4630acf7990"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::RTOS_ISR_USER_00" ref="aa45ffbc5d63a6d4abf52d4630acf7990" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ISR_USER_00&#160;&#160;&#160;ADC_vect</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The name of the interrupt vector which is assigned to application interrupt 0. The supported vector names can be derived from table 14-1 on page 105 in the CPU manual, doc2549.pdf (see <a href="http://www.atmel.com">http://www.atmel.com</a>). </p>

</div>
</div>
<a class="anchor" id="a9c1a5203784dfef032e71987acd938e4"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::RTOS_USE_APPL_INTERRUPT_01" ref="a9c1a5203784dfef032e71987acd938e4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_USE_APPL_INTERRUPT_01&#160;&#160;&#160;RTOS_FEATURE_OFF</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable the application defined interrupt 1. See <a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#a5e0fdba99bbc77534b5543411c74bf66">RTOS_USE_APPL_INTERRUPT_00</a> for details. </p>

</div>
</div>
<a class="anchor" id="ae58e83719197ede9e06180f7e7f02e2a"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::RTOS_ISR_USER_01" ref="ae58e83719197ede9e06180f7e7f02e2a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ISR_USER_01&#160;&#160;&#160;xxx_vect</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The name of the interrupt vector which is assigned to application interrupt 1. See <a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#aa45ffbc5d63a6d4abf52d4630acf7990">RTOS_ISR_USER_00</a> for details. </p>

</div>
</div>
<a class="anchor" id="aaa4a8fd0247c89f3d56a45f78893bcec"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::RTOS_DEFINE_TYPE_OF_SYSTEM_TIME" ref="aaa4a8fd0247c89f3d56a45f78893bcec" args="(noBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_DEFINE_TYPE_OF_SYSTEM_TIME</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">noBits</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> uint##noBits##_t uintTime_t;            \
    <span class="keyword">typedef</span> <span class="keywordtype">int</span>##noBits##_t intTime_t;
</pre></div><p>A macro which expands to the code which defines all types which are related to the system timer. We need the unsigned and the related signed type. The macro is applied just once, see below and <a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#aea4eba3e53ed9ad5ac0439a3fd3f4ced">RTOS_DEFINE_TYPE_OF_SYSTEM_TIME_DOXYGEN_TAG</a>. </p>

</div>
</div>
<a class="anchor" id="acf24026fc76a744b3bfeb63b9277cb58"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::rtos_enterCriticalSection" ref="acf24026fc76a744b3bfeb63b9277cb58" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtos_enterCriticalSection</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{                                                                           \
    cli();                                                                  \
    TIMSK2 &amp;= ~_BV(TOIE2);                                                  \
    ADCSRA &amp;= ~_BV(ADIE);                                                   \
    sei();                                                                  \
                                                                            \
}
</pre></div><p>This routine in cooperation with rtos_leaveCriticalSection makes the code sequence located between the two functions atomic with respect to operations of the RTuinOS task scheduler.<br/>
 Any access to data shared between different tasks should be placed inside this pair of functions in order to avoid data inconsistencies due to task switches during the access time. A exception are trivial access operations which are atomic as such, e.g. read or write of a single byte.<br/>
 The function implementation disables the interrupt source for the system timer, which is the only unforeseen, random cause of a task switch in the default configuration of RTuinOS. The implementation of this pair of functions need to be changed if this standard configuration is changed also. Examples of a changed configuration are:<br/>
 The system timer is bound to another interrupt source.<br/>
 External interrupts are enabled and implemented.<br/>
 In any case, the functions need to disable all interrupts, which could lead to a task switch. It is not the intention - although it would work - to simply lock all interrupts globally. The responsiveness of the system would be degraded without need.<br/>
 The use of the function pair cli() and sei() is an alternative to rtos_enter/leaveCriticalSection. Globally locking the interrupts is less expensive than inhibiting a specific set but degrades the responsiveness of the system. cli/sei should preferably be used if the data accessing code is rather short so that the global lock time of all interrupts stays very brief. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The implementation does not permit recursive invocation of the function pair. The status of the interrupt lock is not saved. If two pairs of the functions are nested, the task switches are re-enabled as soon as the inner pair is left - the remaining code in the outer pair of function would no longer be protected against unforeseen task switches. This is the same as if using nested pairs of cli/sei. </dd>
<dd>
This pair of functions is implemented as a macro in the application owned copy of the RTuinOS configuration file. Changing the implementation means to edit this file. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#ad4a77dc2ff9b06fc8e39ed35e768c0ae">RTOS_ISR_SYSTEM_TIMER_TIC</a> </dd>
<dd>
<a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#a5e0fdba99bbc77534b5543411c74bf66">RTOS_USE_APPL_INTERRUPT_00</a> </dd>
<dd>
<a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#a9c1a5203784dfef032e71987acd938e4">RTOS_USE_APPL_INTERRUPT_01</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7a560f736b13c931bee8c498fa0f32d3"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::rtos_leaveCriticalSection" ref="a7a560f736b13c931bee8c498fa0f32d3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtos_leaveCriticalSection</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{                                                                           \
    cli();                                                                  \
    TIMSK2 |= _BV(TOIE2);                                                   \
    ADCSRA |= _BV(ADIE);                                                    \
    sei();                                                                  \
                                                                            \
}
</pre></div><p>This macro is the counterpart of <a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#acf24026fc76a744b3bfeb63b9277cb58">rtos_enterCriticalSection</a>. Please refer to <a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html#acf24026fc76a744b3bfeb63b9277cb58">rtos_enterCriticalSection</a> for deatils. </p>

</div>
</div>
<a class="anchor" id="aea4eba3e53ed9ad5ac0439a3fd3f4ced"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::RTOS_DEFINE_TYPE_OF_SYSTEM_TIME_DOXYGEN_TAG" ref="aea4eba3e53ed9ad5ac0439a3fd3f4ced" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_DEFINE_TYPE_OF_SYSTEM_TIME_DOXYGEN_TAG</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The type of the system time. The system time is a cyclic integer value. If the use case of the RTOS is a traditional scheduling of regular tasks of different priorities its unit is often chosen to be the period time of the fastest regular time. But in general the time doesn't need to be regular and its unit doesn't matter.<br/>
 You may define the time to be any unsigned integer considering following trade off: The shorter the type the less the system overhead. Be aware that many operations in the kernel are time based.<br/>
 The longer the type the larger is the maximum ratio of period times of slowest and fastest task. This maximum ratio is half the maximum number. If you implement tasks of e.g. 10 ms, 100 ms and 1000 ms, this could be handled with a uint8_t. If you want to have an additional 1ms task, uint8 will no longer suffice, you need at least uint16_t. (uint32_t is probably never useful.)<br/>
 The longer the type the higher can the resolution of timeout timers be chosen when waiting for events. The resolution is the tic frequency of the system time. With an 8 Bit system time one would probably choose a tic frequency identical to the repetition speed of the fastest task (or at least only higher by a small factor). Then, this task can only specify a timeout which ends at the next regular due time of the task. The statement made before needs refinement: Half the maximum number of the chosen data type is the possible maximum of the ratio of the period time of the slowest task and the resolution of timeout specifications.<br/>
 The shorter the type the higher the probability of not recognizing task overruns when implementing the use case mentioned before: Due to the cyclic character of the time definition a time in the past is seen as a time in the future, if it is past more than half the maximum integer number.<br/>
 Example: Data type is uint8_t. A task is implemented as regular task of 100 units. Thus, at the end of the functional code it suspends itself with time increment 100 units. Let's say it had been resumed at time 123. In normal operation, no task overrun it will end e.g. 87 tics later, i.e. at 210. The demanded resume time is 123+100 = 223, which is seen as +13 in the future. If the task execution was too long and ended e.g. after 110 tics, the system time was 123+110 = 233. The demanded resume time 223 is seen in the past and a task overrun is recognized. A problem appears at excessive task overruns. If the execution had e.g. taken 230 tics the current time is 123 + 230 = 353 - or 97 due to its cyclic character. The demanded resume time 223 is 126 tics ahead, which is considered a future time - no task overrun is recognized. The problem appears if the overrun lasts more than half the system time cycle. With uint16_t this problem becomes negligible.<br/>
 This typedef doesn't have the meaning of hiding the type. In contrary, the character of the time being a simple unsigned integer should be visible to the user. The meaning of the typedef only is to have an implementation with user-selectable number of bits for the integer. Therefore we choose its name <em>uintTime_t</em> similar to the common integer types.<br/>
 The argument of the macro, which actually makes the required typedefs is set to either 8, 16 or 32; the meaning is number of bits. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Please find a more detailed discussion of the configuration of the system time data type in the RTuinOS manual. </dd>
<dd>
Please ignore the appendix _DOXYGEN_TAG in the displayed name of the macro. This is a dummy define, just to make this explanation appear. The doxygen parser gets confused about the (nested) syntax of the true macro. Inspect the header file to see. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9d2183f5770c62869b0716c3bdfab83"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::RTOS_OVERRUN_TASK_IS_IMMEDIATELY_DUE" ref="ad9d2183f5770c62869b0716c3bdfab83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_OVERRUN_TASK_IS_IMMEDIATELY_DUE&#160;&#160;&#160;RTOS_FEATURE_ON</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Normally, when the overrun of a regular task has been recognized the task is made due immediately (instead of sticking to the nominal due time, which will be reached only in the next system timer cycle).<br/>
 If the short system timer is chosen and if there are regular tasks having a cycle time greater than half the timer cycle (i.e. above 127 tics) the probability of faulty recognizing task overruns is close to one (see above). In this situation it can make sense not to react on a recognized task overrun, i.e. not to make the task due immediately. Since faster tasks are more typical than very slow tasks the feature is active by standard even for the short system timer. An application may however turn it off (with care) if it uses that slow regular tasks.<br/>
 The counters for task overruns are still supported even if this feature is turned off. The counter for the very slow task should not be evaluated. If you turn this feature off you anticipate false task overrun recognitions for this task.<br/>
 If the 16 or 32 Bit system timer is in use it makes no sense to turn the feature off; moreover, it is dangerous to do, as a true, properly recognized task overrun would lead to an almost dead task. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a7f77cb42f6112e1647ce7307a910aeba"></a><!-- doxytag: member="tc14/rtosConfig/rtos.config.h::uintSemaphore_t" ref="a7f77cb42f6112e1647ce7307a910aeba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="rtos_8config_8template_8h.html#a7f77cb42f6112e1647ce7307a910aeba">uintSemaphore_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The implementation of a semaphore is a simple unsigned integer. The value means the number of resources managed by the semaphore. In a resource management system it may be the number of available pooled resources, which can be still checked out by the clients, or it is the number of produced objects in a producer-consumer system. In any application, the maximum number of managed objects need to fit into the data type of the semaphore. Use the smallest possible data type, which fits to all your semaphores.<br/>
 Possible data types for semaphores are uint8_t, uint16_t and uint32_t. </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="tc14_2rtos_config_2rtos_8config_8h.html">rtos.config.h</a>      </li>
      <li class="footer">Generated on Mon Aug 26 2013 12:30:20 for RTuinOS by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
